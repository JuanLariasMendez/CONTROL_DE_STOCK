package com.alura.jdbc.dao;import com.alura.jdbc.modelo.Producto;import java.sql.*;public class ProductoDAO {    //Atributo de la conexion    final private Connection con;    //Se asigna la conexion en un contructor    public ProductoDAO(Connection con){        //Asignamos la variable con al constructor connection que tenemos en la clase        this.con = con;    }    //Acá se guardara toda la logica del productoController    public void guardar(Producto producto) throws SQLException {        /*        No neceistamos mas instanciar una nueva conexion, ya que esta esta insanticiada dentro de la clase ProductoDAO         sacamos esta responsabilidad del propio método de estar solicitando una conexión para el data source.        ConnectionFactory factory = new ConnectionFactory();        //Se recupera la conexion        final Connection con = factory.recuperaConexion();*/        try(con){            //Tomando el control de la transaccion, para decir cuando se realiza el commit            con.setAutoCommit(false);            //Creado un statement, y concatenango los valores			/*Statement statement = con.createStatement();			statement.execute("INSERT INTO PRODUCTO(nombre, descripcion, cantidad) "			+ " VALUES('" +producto.get("NOMBRE")+ "', '"			+ producto.get("DESCRIPCION")+ "', "			+ producto.get("CANTIDAD") + ")", Statement.RETURN_GENERATED_KEYS);*/            //Preparando un statemen para pasar la responsabilidad a SQL de validar la query            final PreparedStatement statement = con.prepareStatement("INSERT INTO PRODUCTO"                            + "(nombre, descripcion, cantidad)"                            + " VALUES(?,?,?)",                    Statement.RETURN_GENERATED_KEYS);            //try(statement){            //Si sale la transaccion se efectua, tenemos un commit y si ocurre un error, tenemos un rollback de la transacción.            //si vamos a estar ejecutando y tomando siempre el menor valor posible para ir guardando y pensando que el máximo que podemos guardar es 50, entonces si la cantidad es mayor que 50, la próxima vez que pasemos por este lazo, por este loop, nosotros tenemos que guardar lo restante.            try(statement){                //si la ejecución acá tiene un error, él ejecuta registro o cualquier cosa que hay acá dentro del try tiene un error, vamos a caer en el catch, nosotros vamos a hacer un rollback de la transacción, vamos a cerrar la conexión y no hay ningún problema. Nosotros cancelamos la ejecución de estas transacciones.				/*do{					// si es la cantidad tiene valor 100 y máximoCantidad es 50, el valor mínimo acá va a ser 50. Si el valor cantidad es 40 por ejemplo y el máximoCantidad es 50, el valor de cantidad para guardar va a ser 40.					int cantidadParaGuardar = Math.min(cantidad,maximoCantidad);*/                //Enviamos el objeto producto para efectuar el reguistro                EjecutaReguistro(producto,statement);                //Acá voy a estar haciendo una substracción del valor de cantidad del máximoCantidad.					/*cantidad -= maximoCantidad;					//Mientras cantidad sea mayor a cero, entonces sigue haciendo el loop				}while (cantidad>0);*/                con.commit();                System.out.println("COMMIT");            }catch (Exception e){                System.out.println("ROLLBACK");                con.rollback();            }        }    }    private static void EjecutaReguistro(Producto producto,PreparedStatement statement) throws SQLException {        //Pruebas de commits exitosos		/*if (cantidad<50){			throw new RuntimeException("Ocurrio un error");		}*/        //Setteando los valores de la query, estos tienen que ir en el mismo orden en el que lo pusimos en el query        statement.setString(1, producto.getNombre());        statement.setString(2, producto.getDescripcion());        statement.setInt(3, producto.getCantidad());        statement.execute();        /*-----try catch whitch resourese------*/        //---------Forma de java 7 para atras-----------        //Para que el JDBC se encargue de cerrar los stetemts por su cuenta y no tener que hacerlo manualmente en cada parte del código        /*try(ResultSet resultSet = statement.getGeneratedKeys();)*//*En esta variable tenemos el listado de IDs que fueron generados)*//*{			//Con este loop, podemos listar el listado de IDs que fue generado			while (resultSet.next()) {				System.out.println(						String.format(								"Fue insertado el producto de ID:%d",								resultSet.getInt(1)));			}		}*/        //---------Forma de java 9 en adelante-----------        final ResultSet resultSet = statement.getGeneratedKeys();        try(resultSet)/*En esta variable tenemos el listado de IDs que fueron generados)*/{            //Con este loop, podemos listar el listado de IDs que fue generado            while (resultSet.next()) {                producto.setId(resultSet.getInt(1));                System.out.println(String.format("Fue insertado el producto %s", producto));				/*System.out.println(						//Em vez de imprimir el ID genera roducto de ID:%d",								resultSet.getInt(1));*/            }        }    }}